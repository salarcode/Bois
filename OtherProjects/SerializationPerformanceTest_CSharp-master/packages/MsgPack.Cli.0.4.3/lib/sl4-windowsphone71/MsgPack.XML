<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MsgPack</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.Contracts.Contract">
            <summary>
            	Compatibility Mock.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.PureAttribute">
            <summary>
            	Compatibility Mock.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractClassAttribute">
            <summary>
            	Compatibility Mock.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractClassForAttribute">
            <summary>
            	Compatibility Mock.
            </summary>
        </member>
        <member name="T:MsgPack.BigEndianBinary">
            <summary>
            	Define bit operations which enforce big endian.
            </summary>
        </member>
        <member name="T:MsgPack.Binary">
            <summary>
            	Defines binary related utilities.
            </summary>
        </member>
        <member name="F:MsgPack.Binary.Empty">
            <summary>
            	Singleton empty <see cref="T:System.Byte"/>[].
            </summary>
        </member>
        <member name="T:MsgPack.CollectionDebuggerProxy`1">
            <summary>
            	Debugger type proxy for <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The element type of the collection.</typeparam>
        </member>
        <member name="T:MsgPack.DictionaryDebuggerProxy`2">
            <summary>
            	Debugger type proxy for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="T:MsgPack.Float32Bits">
            <summary>
            	Provides bit access for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Value">
            <summary>
            	Value as <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte0">
            <summary>
            	Most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte1">
            <summary>
            	2nd bit from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte2">
            <summary>
            	3rd byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte3">
            <summary>
            	Least byte of current endian.
            </summary>
        </member>
        <member name="M:MsgPack.Float32Bits.#ctor(System.Single)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float32Bits"/> type from specified <see cref="T:System.Single"/>.
            </summary>
            <param name="value">Value of <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:MsgPack.Float32Bits.#ctor(System.Byte[],System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float32Bits"/> type from specified <see cref="T:System.Byte"/>[] which is big endian.
            </summary>
            <param name="bigEndianBytes">Array of <see cref="T:System.Byte"/> which contains bytes in big endian.</param>
            <param name="offset">Offset to read.</param>
        </member>
        <member name="T:MsgPack.Float64Bits">
            <summary>
            	Provides bit access for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Value">
            <summary>
            	Value as <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte0">
            <summary>
            	Most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte1">
            <summary>
            	2nd bit from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte2">
            <summary>
            	3rd byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte3">
            <summary>
            	4th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte4">
            <summary>
            	5th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte5">
            <summary>
            	6th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte6">
            <summary>
            	7th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte7">
            <summary>
            	Least significant byte of current endian.
            </summary>
        </member>
        <member name="M:MsgPack.Float64Bits.#ctor(System.Double)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float64Bits"/> type from specified <see cref="T:System.Double"/>.
            </summary>
            <param name="value">Value of <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:MsgPack.Float64Bits.#ctor(System.Byte[],System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float64Bits"/> type from specified <see cref="T:System.Byte"/>[] which is big endian.
            </summary>
            <param name="bigEndianBytes">Array of <see cref="T:System.Byte"/> which contains bytes in big endian.</param>
            <param name="offset">Offset to read.</param>
        </member>
        <member name="T:MsgPack.InvalidMessagePackStreamException">
            <summary>
            	Exception occured when inbound stream is invalid as serialized Message Pack stream.
            </summary>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="T:MsgPack.IPackable">
            <summary>
            	Represents objects which knows how to pack ifself using specified <see cref="T:MsgPack.Packer"/>.
            </summary>
        </member>
        <member name="M:MsgPack.IPackable.PackToMessage(MsgPack.Packer,MsgPack.PackingOptions)">
            <summary>
            	Pack this instance itself using specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/>.</param>
            <param name="options">Packing options. This value can be null.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="packer"/> is null.</exception>
        </member>
        <member name="T:MsgPack.Unpacker">
            <summary>
            	Implements deserializing feature of MsgPack.
            </summary>
            <remarks name="MsgPack.Unpacker">
    <see cref="T:MsgPack.Unpacker"/> implements three mode, that is 'Streaming', 'Enumerating', 'Skipping', and 'Subtree'.
    <list type="bullet">
      <item>
        <para>
          <strong>Streaming</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.Read"/> is called, unpacker go into 'Streaming' mode.
          In this mode, unpacker unpacks individual entries as <see cref="T:MsgPack.MessagePackObject"/> via <see cref="P:MsgPack.Unpacker.Data"/> property.
          If the underlying stream is ended unexpectedly, then <see cref="M:MsgPack.Unpacker.Read"/> returns <c>false</c>, and <see cref="P:MsgPack.Unpacker.Data"/> will be <c>null</c>.
          Note that if the underlying stream is feeded, that is the <see cref="P:Stream.Length"/> is expanded and its <see cref="P:Stream.Position"/> is not forwarded,
          subsequent <see cref="M:MsgPack.Unpacker.Read"/> invocation will success, and <see cref="P:MsgPack.Unpacker.Data"/> is set as complete entry which reflects feeded binary.
        </para>
        <para>
          If the reading of the entry is completed, that is the <see cref="P:MsgPack.Unpacker.Data"/> is not <c>null</c>, unpacker can transit other mode.
        </para>
      </item>
      <item>
        <para>
          <strong>Enumerating</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.GetEnumerator"/> is called and the enumeration is started, unpacker go into 'Enumerating' mode.
          In this mode, unpacker unpacks individual entries as <see cref="T:MsgPack.MessagePackObject"/> via <see cref="P:IEnumerator{T}.Current"/> property.
          If the underlying stream is ended unexpectedly, enumeration is interrupted.
          The interrupted unpacker cannot be resume.
        </para>
        <para>
          Once the enumeration is completed gracefully, unpacker can transit other mode.
        </para>
      </item>
      <item>
        <para>
          <strong>Skipping</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.Skip"/> is called, unpacker go into 'Skipping' mode.
          In this mode, unpacker scans the subtree where the root is current item, then returns skipped byte length.
          If the underlying stream is ended unexpectedly, it returns <c>null</c>.
          Note that if the underlying stream is feeded, that is the <see cref="P:Stream.Length"/> is expanded and its <see cref="P:Stream.Position"/> is not forwarded,
          subsequent <see cref="M:MsgPack.Unpacker.Skip"/> invocation will success, and returns length as complete entry which reflects feeded binary.
          <note>
            If the underlying <see cref="T:System.IO.Stream"/> is cannot be seeked (that is, <see cref="P:Stream.CanSeek"/> is <c>false</c>),
            DO NOT use this method.
            You can buffering the content via <see cref="T:System.IO.MemoryStream"/> instead, for example.
          </note>
        </para>
        <para>
          If the skipping of the subtree is completed, that is the return value is not <c>null</c>, unpacker can transit other mode.
        </para>
      </item>
      <item>
        <para>
          <strong>Subtree</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.ReadSubtree"/> is called, unpacker go into 'Subtree' mode.
          In this mode, any operation for this unpacker instance is invalid.
          Instead of use this instance itself, you can use subtree unpacker returned from <see cref="M:MsgPack.Unpacker.ReadSubtree"/>.
          The subtree unpacker is the instance which scope is limited to the subtree where the root is the current entry when <see cref="M:MsgPack.Unpacker.ReadSubtree"/> is called.
          The subtree unpacker also have its own mode and state.
          <note>
            <see cref="M:MsgPack.Unpacker.Dispose"/> of the subtree unpacker must be called to indicate subtree unpacking is gracefully completed.
            When the extra entries are remained in the subtree, these will be skipped on the disposal process.
          </note>
        </para>
        <para>
          Once the subtree unpacking is completed gracefully, that is, <see cref="M:MsgPack.Unpacker.Dispose"/> on the subtree unpacker called, the parant unpacker can transit other mode.
        </para>
      </item>
    </list>
  </remarks>
            <seealso cref="T:MsgPack.Unpacking"/>
        </member>
        <member name="M:MsgPack.Unpacker.VerifyMode(MsgPack.Unpacker.UnpackerMode)">
            <summary>
            	Verifies the mode.
            </summary>
            <param name="mode">The mode to be.</param>
            <exception cref="T:System.ObjectDisposedException">
            	Already disposed.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            	Is in incompatible mode.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.VerifyIsNotDisposed">
            <summary>
            	Verifies this instance is not disposed.
            </summary>
        </member>
        <member name="M:MsgPack.Unpacker.NewInvalidModeException">
            <summary>
            	Returns new exception instance to notify invalid mode transition.
            </summary>
            <returns>New exception instance to notify invalid mode transition.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Create(System.IO.Stream)">
            <summary>
            	 Creates the new <see cref="T:MsgPack.Unpacker"/> from specified stream.
            </summary>
            <param name="stream">The stream to be unpacked. This stream will be closed when <see cref="M:MsgPack.Packer.Dispose(System.Boolean)"/> is called.</param>
            <returns><see cref="T:MsgPack.Unpacker"/> instance.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Create(System.IO.Stream,System.Boolean)">
            <summary>
            	 Creates the new <see cref="T:MsgPack.Unpacker"/> from specified stream.
            </summary>
            <param name="stream">The stream to be unpacked.</param>
            <param name="ownsStream">
            	<c>true</c> to close <paramref name="stream"/> when this instance is disposed;
            	<c>false</c>, otherwise.
            </param>
            <returns><see cref="T:MsgPack.Unpacker"/> instance.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Unpacker"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.Unpacker.Dispose">
            <summary>
            	Releases all managed resources.
            </summary>
        </member>
        <member name="M:MsgPack.Unpacker.Dispose(System.Boolean)">
            <summary>
            	Releases unmanaged and optionally managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:MsgPack.Unpacker.ReadSubtree">
            <summary>
            	Starts unpacking of current subtree.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Unpacker"/> to unpack current subtree.
            	This will not be <c>null</c>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	This unpacker is not positioned on the header of array nor map.
            	Or this unpacker already returned <see cref="T:MsgPack.Unpacker"/> for subtree and it has not been closed yet.
            </exception>
            <remarks>
            	While subtree unpacker is used, this instance will be 'locked' (called 'subtree' mode) and be unavailable.
            	When you finish to unpack subtree, you must invoke <see cref="M:MsgPack.Unpacker.Dispose"/>, 
            	or you faces <see cref="T:System.InvalidOperationException"/> when you use the parent instance.
            	Subtree unpacker can only unpack subtree, so you can handle collection deserialization easily.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacker.ReadSubtreeCore">
            <summary>
            	Starts unpacking of current subtree.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Unpacker"/> to unpack current subtree.
            	This will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.EndReadSubtree">
            <summary>
            	Ends the read subtree.
            </summary>
            <remarks>
            	This method only be called from subtree unpacker.
            	Custom subtree unpacker implementation must call this method from its <see cref="M:MsgPack.Unpacker.Dispose(System.Boolean)"/> method.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacker.Read">
            <summary>
            	Reads next Message Pack entry.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	This instance is in 'subtree' mode.
            </exception>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	The underying stream unexpectedly ended.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadCore">
            <summary>
            	Reads next Message Pack entry.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.GetEnumerator">
            <summary>
            	Gets <see cref="T:System.Collections.Generic.IEnumerator`1"/> to enumerate <see cref="T:MsgPack.MessagePackObject"/> from source stream.
            </summary>
            <returns><see cref="T:System.Collections.Generic.IEnumerator`1"/> to enumerate <see cref="T:MsgPack.MessagePackObject"/> from source stream.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Skip">
            <summary>
            	Skips the subtree where the root is the current entry, and returns skipped byte length.
            </summary>
            <returns>
            	Skipped byte length.
            	If the subtree is not completed, then <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.SkipCore">
            <summary>
            	Skips the subtree where the root is the current entry, and returns skipped byte length.
            </summary>
            <returns>
            	Skipped byte length.
            	If the subtree is not completed, then <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.ReadItem">
            <summary>
            	Gets a current item or collection as single <see cref="T:MsgPack.MessagePackObject"/> from the stream.
            </summary>
            <returns>
            	A read item or collection from the stream.
            	Or <c>null</c> when stream is ended.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.ReadItemData">
            <summary>
            	Gets a current item or collection as single <see cref="T:MsgPack.MessagePackObject"/> from the stream.
            </summary>
            <returns>
            	A read item or collection from the stream.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">The stream unexpectedly ends.</exception>
        </member>
        <member name="M:MsgPack.Unpacker.UnpackSubtree">
            <summary>
            	Unpacks current subtree and returns subtree root as array or map.
            </summary>
            <returns>
            	An unpacked array or map when current position is array or map header.
            	<c>null</c> when current position is not array nor map header.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.UnpackSubtreeData">
            <summary>
            	Unpacks current subtree and returns subtree root as array or map.
            </summary>
            <returns>
            	An unpacked array or map when current position is array or map header.
            	Or <see cref="P:MsgPack.Unpacker.LastReadData"/> when current position is not array nor map header.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.ReadBoolean(System.Boolean@)">
            <summary>
            	Reads next <see cref="T:System.Boolean"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Boolean"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Boolean"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableBoolean(System.Nullable{System.Boolean}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Boolean"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Boolean"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Boolean"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadByte(System.Byte@)">
            <summary>
            	Reads next <see cref="T:System.Byte"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Byte"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Byte"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableByte(System.Nullable{System.Byte}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Byte"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Byte"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Byte"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadSByte(System.SByte@)">
            <summary>
            	Reads next <see cref="T:System.SByte"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.SByte"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.SByte"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableSByte(System.Nullable{System.SByte}@)">
            <summary>
            	Reads next nullable <see cref="T:System.SByte"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.SByte"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.SByte"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadInt16(System.Int16@)">
            <summary>
            	Reads next <see cref="T:System.Int16"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Int16"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Int16"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableInt16(System.Nullable{System.Int16}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Int16"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Int16"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Int16"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadUInt16(System.UInt16@)">
            <summary>
            	Reads next <see cref="T:System.UInt16"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.UInt16"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.UInt16"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableUInt16(System.Nullable{System.UInt16}@)">
            <summary>
            	Reads next nullable <see cref="T:System.UInt16"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.UInt16"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.UInt16"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadInt32(System.Int32@)">
            <summary>
            	Reads next <see cref="T:System.Int32"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Int32"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Int32"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableInt32(System.Nullable{System.Int32}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Int32"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Int32"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Int32"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadUInt32(System.UInt32@)">
            <summary>
            	Reads next <see cref="T:System.UInt32"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.UInt32"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.UInt32"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableUInt32(System.Nullable{System.UInt32}@)">
            <summary>
            	Reads next nullable <see cref="T:System.UInt32"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.UInt32"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.UInt32"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadInt64(System.Int64@)">
            <summary>
            	Reads next <see cref="T:System.Int64"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Int64"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Int64"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableInt64(System.Nullable{System.Int64}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Int64"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Int64"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Int64"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadUInt64(System.UInt64@)">
            <summary>
            	Reads next <see cref="T:System.UInt64"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.UInt64"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.UInt64"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableUInt64(System.Nullable{System.UInt64}@)">
            <summary>
            	Reads next nullable <see cref="T:System.UInt64"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.UInt64"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.UInt64"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadSingle(System.Single@)">
            <summary>
            	Reads next <see cref="T:System.Single"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Single"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Single"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableSingle(System.Nullable{System.Single}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Single"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Single"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Single"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadDouble(System.Double@)">
            <summary>
            	Reads next <see cref="T:System.Double"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:System.Double"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:System.Double"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableDouble(System.Nullable{System.Double}@)">
            <summary>
            	Reads next nullable <see cref="T:System.Double"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:System.Double"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:System.Double"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadMessagePackExtendedTypeObject(MsgPack.MessagePackExtendedTypeObject@)">
            <summary>
            	Reads next <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadNullableMessagePackExtendedTypeObject(System.Nullable{MsgPack.MessagePackExtendedTypeObject}@)">
            <summary>
            	Reads next nullable <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> value from current stream.
            </summary>
            <returns>
            	The nullable <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> value read from current data source successfully.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not compatible for the nullable <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> type.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadArrayLength(System.Int64@)">
            <summary>
            	Reads next array length value from current stream.
            </summary>
            <param name="result">
            	The array length read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not an array.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadMapLength(System.Int64@)">
            <summary>
            	Reads next map length value from current stream.
            </summary>
            <param name="result">
            	The map length read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not a map.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadBinary(System.Byte[]@)">
            <summary>
            	Reads next byte array value from current stream.
            </summary>
            <param name="result">
            	The byte array read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not a raw.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadString(System.String@)">
            <summary>
            	Reads next utf-8 encoded string value from current stream.
            </summary>
            <param name="result">
            	The decoded utf-8 encoded string read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	A value read from data source is not a raw.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadObject(MsgPack.MessagePackObject@)">
            <summary>
            	Reads next value from current stream.
            </summary>
            <param name="result">
            	The <see cref="T:MsgPack.MessagePackObject"/> which represents a value read from current stream to be stored when operation is succeeded.
            </param>
            <returns>
            	<c>true</c> if expected value was read from stream; <c>false</c> if no more data on the stream.
            	Note that this method throws exception for unexpected state. See exceptions section.
            </returns>
            <exception cref="T:MsgPack.InvalidMessagePackStreamException">
            	Cannot read a value because the underlying stream unexpectedly ends.
            </exception>
        </member>
        <member name="P:MsgPack.Unpacker.Data">
            <summary>
            	Gets a last unpacked data.
            </summary>
            <value>A last unpacked data.</value>
            <remarks>
            	<note class="warning">
            		In default implementation, this property never returning <c>null</c> even if it had not been unpacked any objects.
            	</note>
            	If you use any of direct APIs (methods which return non-<see cref="T:MsgPack.MessagePackObject"/>), 
            	then this property to be invalidated.
            	Note that the actual value of invalidated this property is undefined.
            </remarks>
        </member>
        <member name="P:MsgPack.Unpacker.LastReadData">
            <summary>
            	Gets a last unpacked data.
            </summary>
            <value>A last unpacked data. Initial value is <see cref="F:MsgPack.MessagePackObject.Nil"/>.</value>
            <remarks>
            	If you use any of direct APIs (methods which return non-<see cref="T:MsgPack.MessagePackObject"/>), 
            	then this property to be invalidated.
            	Note that the actual value of invalidated this property is undefined.
            </remarks>
        </member>
        <member name="P:MsgPack.Unpacker.IsArrayHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to array header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to array header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Unpacker.IsMapHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to map header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to map header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Unpacker.IsCollectionHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to array or map header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to array or map header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Unpacker.ItemsCount">
            <summary>
            	Gets the items count for current array or map.
            </summary>
            <value>
            	The items count for current array or map.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	Both of the <see cref="P:MsgPack.Unpacker.IsArrayHeader"/> and <see cref="P:MsgPack.Unpacker.IsMapHeader"/> are <c>false</c>.
            </exception>
        </member>
        <member name="P:MsgPack.Unpacker.UnderlyingStream">
            <summary>
            	Gets the underlying stream to handle direct API.
            </summary>
            <exception cref="T:System.NotSupportedException">
            	This instance does not supoort direct API.
            </exception>
        </member>
        <member name="M:MsgPack.ItemsUnpacker.ReadSubtreeCore">
            <summary>
            	Starts unpacking of current subtree.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Unpacker"/> to unpack current subtree.
            	This will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.ItemsUnpacker.ReadSubtreeItem">
            <summary>
            	Read subtree item from current stream.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
            <remarks>
            	This method only be called from <see cref="T:MsgPack.SubtreeUnpacker"/>.
            </remarks>
        </member>
        <member name="T:MsgPack.IUnpackable">
            <summary>
            	Defines interface for object which can be deserialzed from MessagePack object.
            </summary>
        </member>
        <member name="M:MsgPack.IUnpackable.UnpackFromMessage(MsgPack.Unpacker)">
            <summary>
            	Restore object state from specified <see cref="T:MsgPack.Unpacker"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unpacker"/> is <c>null</c>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Cannot restore state from the stream.</exception>
        </member>
        <member name="T:MsgPack.MessageNotSupportedException">
            <summary>
            	Exception occurs when serialized stream contains structures or features which will never be supported by MsgPack/CLI implementation.
            </summary>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="T:MsgPack.MessagePackConvert">
            <summary>
            	Define common convert rountines specific to MessagePack.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackConvert.EncodeString(System.String)">
            <summary>
            	Encode specified string by default encoding.
            </summary>
            <param name="value">String value.</param>
            <returns>Encoded <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="value"/> is null.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackConvert.DecodeStringStrict(System.Byte[])">
            <summary>
            	Decode specified byte[] by default encoding.
            </summary>
            <param name="value">Byte[] value.</param>
            <returns>Decoded <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="value"/> is null.
            </exception>
            <exception cref="T:System.Text.DecoderFallbackException">
            	<paramref name="value"/> contains non-UTF-8 bits.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackConvert.ToDateTimeOffset(System.Int64)">
            <summary>
            	Convert specified <see cref="T:System.Int64"/> to <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="value">
            	<see cref="T:System.Int64"/> value which is unpacked from packed message and may represent date-time value.
            </param>
            <returns>
            	<see cref="T:System.DateTimeOffset"/>. Offset of this value always 0.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackConvert.ToDateTime(System.Int64)">
            <summary>
            	Convert specified <see cref="T:System.Int64"/> to <see cref="T:System.DateTime"/>.
            </summary>
            <param name="value">
            	<see cref="T:System.Int64"/> value which is unpacked from packed message and may represent date-time value.
            </param>
            <returns>
            	<see cref="T:System.DateTime"/>. This value is always UTC.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackConvert.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            	Convert specified <see cref="T:System.DateTimeOffset"/> to <see cref="T:System.Int64"/> as MessagePack defacto-standard.
            </summary>
            <param name="value"><see cref="T:System.DateTimeOffset"/>.</param>
            <returns>
            	UTC epoc time from 1970/1/1 0:00:00, in milliseconds.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackConvert.FromDateTime(System.DateTime)">
            <summary>
            	Convert specified <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/> as MessagePack defacto-standard.
            </summary>
            <param name="value"><see cref="T:System.DateTime"/>.</param>
            <returns>
            	UTC epoc time from 1970/1/1 0:00:00, in milliseconds.
            </returns>
        </member>
        <member name="T:MsgPack.MessagePackExtendedTypeObject">
            <summary>
            	Represents Message Pack extended type object.
            </summary>
        </member>
        <member name="F:MsgPack.MessagePackExtendedTypeObject._typeCode">
            <summary>
            	A type code of this object.
            </summary>
        </member>
        <member name="F:MsgPack.MessagePackExtendedTypeObject._body">
            <summary>
            	A binary value portion of this object.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.GetBody">
            <summary>
            	Gets a copy of the binary value portion of this object.
            </summary>
            <value>
            	A copy of the binary value portion of this object. This value will not be null.
            </value>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.#ctor(System.Byte,System.Byte[])">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> struct.
            </summary>
            <param name="typeCode">A type code of this extension object.</param>
            <param name="body">A binary value portion.</param>
            <exception cref="T:System.ArgumentException">
            	The <paramref name="typeCode"/> is over 127. Higher values are reserved for MessagePack format specification.
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> is <c>null</c>.</exception>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.Unpack(System.Byte,System.Byte[])">
            <summary>
            	Creates a new instance of the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> struct.
            </summary>
            <param name="typeCode">A type code of this extension object.</param>
            <param name="body">A binary value portion.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="body"/> is <c>null</c>.</exception>
            <remarks>
            	This method allows reserved type code. It means that this method does not throw exception when the <paramref name="typeCode"/> is reserved value (greater then 0x7F).
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.ToString">
            <summary>
            	Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            	A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.GetHashCode">
            <summary>
            	Returns a hash code for this instance.
            </summary>
            <returns>
            	A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.Equals(System.Object)">
            <summary>
            	Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.Equals(MsgPack.MessagePackExtendedTypeObject)">
            <summary>
            	Determines whether the specified <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.op_Equality(MsgPack.MessagePackExtendedTypeObject,MsgPack.MessagePackExtendedTypeObject)">
            <summary>
            	Determines whether the specified <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>s are equal.
            </summary>
            <param name="left">A <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.</param>
            <param name="right">A <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>s are equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackExtendedTypeObject.op_Inequality(MsgPack.MessagePackExtendedTypeObject,MsgPack.MessagePackExtendedTypeObject)">
            <summary>
            	Determines whether the specified <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>s are not equal.
            </summary>
            <param name="left">A <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.</param>
            <param name="right">A <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>s are not equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:MsgPack.MessagePackExtendedTypeObject.TypeCode">
            <summary>
            	Gets a type code of this object.
            </summary>
            <value>
            	A type code. Note that values over <see cref="F:System.SByte.MaxValue"/> are reserved for MsgPack spec itself.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackExtendedTypeObject.Body">
            <summary>
            	Gets a binary value portion of this object.
            </summary>
            <value>
            	A binary value portion of this object. This value will not be null.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackExtendedTypeObject.IsValid">
            <summary>
            	Gets a value indicating whether this instance is valid.
            </summary>
            <value>
              <c>true</c> if this instance is valid; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:MsgPack.MessagePackObject">
            <summary>
            	Represents deserialized object of MsgPack.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Boolean)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Boolean"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Byte)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Byte"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.SByte)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.SByte"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Int16)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Int16"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.UInt16)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.UInt16"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Int32"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.UInt32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.UInt32"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Int64)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Int64"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.UInt64)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.UInt64"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Single)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Single"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Double)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Double"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.String"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Byte[])">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Byte"/>[] instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackExtendedTypeObject)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsBoolean">
            <summary>
            	Convert this instance to <see cref="T:System.Boolean"/> instance.
            </summary>
            <returns><see cref="T:System.Boolean"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsByte">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/> instance.
            </summary>
            <returns><see cref="T:System.Byte"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsSByte">
            <summary>
            	Convert this instance to <see cref="T:System.SByte"/> instance.
            </summary>
            <returns><see cref="T:System.SByte"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsInt16">
            <summary>
            	Convert this instance to <see cref="T:System.Int16"/> instance.
            </summary>
            <returns><see cref="T:System.Int16"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsUInt16">
            <summary>
            	Convert this instance to <see cref="T:System.UInt16"/> instance.
            </summary>
            <returns><see cref="T:System.UInt16"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsInt32">
            <summary>
            	Convert this instance to <see cref="T:System.Int32"/> instance.
            </summary>
            <returns><see cref="T:System.Int32"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsUInt32">
            <summary>
            	Convert this instance to <see cref="T:System.UInt32"/> instance.
            </summary>
            <returns><see cref="T:System.UInt32"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsInt64">
            <summary>
            	Convert this instance to <see cref="T:System.Int64"/> instance.
            </summary>
            <returns><see cref="T:System.Int64"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsUInt64">
            <summary>
            	Convert this instance to <see cref="T:System.UInt64"/> instance.
            </summary>
            <returns><see cref="T:System.UInt64"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsSingle">
            <summary>
            	Convert this instance to <see cref="T:System.Single"/> instance.
            </summary>
            <returns><see cref="T:System.Single"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsDouble">
            <summary>
            	Convert this instance to <see cref="T:System.Double"/> instance.
            </summary>
            <returns><see cref="T:System.Double"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsString">
            <summary>
            	Convert this instance to <see cref="T:System.String"/> instance.
            </summary>
            <returns><see cref="T:System.String"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsBinary">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/>[] instance.
            </summary>
            <returns><see cref="T:System.Byte"/>[] instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsMessagePackExtendedTypeObject">
            <summary>
            	Convert this instance to <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> instance.
            </summary>
            <returns><see cref="T:MsgPack.MessagePackExtendedTypeObject"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Boolean)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Boolean"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Boolean"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Byte)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Byte"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.SByte)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.SByte"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.SByte"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Int16)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Int16"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Int16"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.UInt16)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.UInt16"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.UInt16"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Int32)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Int32"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Int32"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.UInt32)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.UInt32"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.UInt32"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Int64)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Int64"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Int64"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.UInt64)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.UInt64"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.UInt64"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Single)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Single"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Single"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Double)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Double"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Double"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.String)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.String"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.String"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Byte[])~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Byte"/>[]instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Byte"/>[] instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(MsgPack.MessagePackExtendedTypeObject)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackExtendedTypeObject"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Boolean">
            <summary>
            	Convert this instance to <see cref="T:System.Boolean"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Boolean"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Byte">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Byte"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.SByte">
            <summary>
            	Convert this instance to <see cref="T:System.SByte"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.SByte"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Int16">
            <summary>
            	Convert this instance to <see cref="T:System.Int16"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Int16"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.UInt16">
            <summary>
            	Convert this instance to <see cref="T:System.UInt16"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.UInt16"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Int32">
            <summary>
            	Convert this instance to <see cref="T:System.Int32"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Int32"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.UInt32">
            <summary>
            	Convert this instance to <see cref="T:System.UInt32"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.UInt32"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Int64">
            <summary>
            	Convert this instance to <see cref="T:System.Int64"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Int64"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.UInt64">
            <summary>
            	Convert this instance to <see cref="T:System.UInt64"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.UInt64"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Single">
            <summary>
            	Convert this instance to <see cref="T:System.Single"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Single"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Double">
            <summary>
            	Convert this instance to <see cref="T:System.Double"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Double"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.String">
            <summary>
            	Convert this instance to <see cref="T:System.String"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.String"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Byte[]">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/>[] instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Byte"/>[] instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~MsgPack.MessagePackExtendedTypeObject">
            <summary>
            	Convert this instance to <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackExtendedTypeObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="F:MsgPack.MessagePackObject.Nil">
            <summary>
            	Instance represents nil. This is equal to default value.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Collections.Generic.IList{MsgPack.MessagePackObject})">
            <summary>
            	Initializes a new instance wraps <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="value">
            	The collection to be copied.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Collections.Generic.IList{MsgPack.MessagePackObject},System.Boolean)">
            <summary>
            	Initializes a new instance wraps <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="value">
            	The collection to be copied or used.
            </param>
            <param name="isImmutable">
            	<c>true</c> if the <paramref name="value"/> is immutable collection;
            	othereise, <c>false</c>.
            </param>
            <remarks>
            	When the collection is truely immutable or dedicated, you can specify <c>true</c> to the <paramref name="isImmutable"/>.
            	When <paramref name="isImmutable"/> is <c>true</c>, this constructor does not copy its contents,
            	or copies its contents otherwise.
            	<note>
            		Note that both of IReadOnlyList and <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> is NOT immutable
            		because the modification to the underlying collection will be reflected to the read-only collection.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackObjectDictionary)">
            <summary>
            	Initializes a new instance wraps <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <param name="value">
            	The dictitonary to be copied.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackObjectDictionary,System.Boolean)">
            <summary>
            	Initializes a new instance wraps <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <param name="value">
            	The dictitonary to be copied or used.
            </param>
            <param name="isImmutable">
            	<c>true</c> if the <paramref name="value"/> is immutable collection;
            	othereise, <c>false</c>.
            </param>
            <remarks>
            	When the collection is truely immutable or dedicated, you can specify <c>true</c> to the <paramref name="isImmutable"/>.
            	When <paramref name="isImmutable"/> is <c>true</c>, this constructor does not copy its contents,
            	or copies its contents otherwise.
            	<note>
            		Note that both of IReadOnlyDictionary and ReadOnlyDictionary is NOT immutable
            		because the modification to the underlying collection will be reflected to the read-only collection.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackString)">
            <summary>
            	Initializes a new instance wraps <see cref="T:MsgPack.MessagePackString"/>.
            </summary>
            <param name="messagePackString"><see cref="T:MsgPack.MessagePackString"/> which represents byte array or UTF-8 encoded string.</param>
        </member>
        <member name="M:MsgPack.MessagePackObject.Equals(System.Object)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="obj"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	If <paramref name="obj"/> is <see cref="T:MsgPack.MessagePackObject"/> and its value is equal to this instance, then true.
            	Otherwise false.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.Equals(MsgPack.MessagePackObject)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="other"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	Whether value of <paramref name="other"/> is equal to this instance or not.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.GetHashCode">
            <summary>
            	Get hash code of this instance.
            </summary>
            <returns>Hash code of this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.ToString">
            <summary>
            	Returns a string that represents the current object.
            </summary>
            <returns>
            	A string that represents the current object.
            </returns>
            <remarks>
            	<note>
            		DO NOT use this value programmically. 
            		The purpose of this method is informational, so format of this value subject to change.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.IsTypeOf``1">
            <summary>
            	Determine whether the underlying value of this instance is specified type or not.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <returns>If the underlying value of this instance is <typeparamref name="T"/> then true, otherwise false.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.IsTypeOf(System.Type)">
            <summary>
            	Determine whether the underlying value of this instance is specified type or not.
            </summary>
            <param name="type">Target type.</param>
            <returns>If the underlying value of this instance is <paramref name="type"/> then true, otherwise false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:MsgPack.MessagePackObject.PackToMessage(MsgPack.Packer,MsgPack.PackingOptions)">
            <summary>
            	Pack this instance itself using specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/>.</param>
            <param name="options">Packing options. This value can be null.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="packer"/> is null.</exception>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsString(System.Text.Encoding)">
            <summary>
            	Gets the underlying value as string encoded with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <returns>
            	The string.
            	Note that some <see cref="T:System.Text.Encoding"/> returns <c>null</c> if the binary is not valid encoded string.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsStringUtf8">
            <summary>
            	Get underlying value as UTF8 string.
            </summary>
            <returns>Underlying raw binary.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsStringUtf16">
            <summary>
            	Get underlying value as UTF-16 string.
            </summary>
            <returns>Underlying string.</returns>
            <remarks>
            	This method detects BOM. If BOM is not exist, them bytes should be Big-Endian UTF-16.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsCharArray">
            <summary>
            	Get underlying value as UTF-16 charcter array.
            </summary>
            <returns>Underlying string.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsEnumerable">
            <summary>
            	Get underlying value as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <returns>Underlying <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsList">
            <summary>
            	Get underlying value as <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>Underlying <see cref="T:System.Collections.Generic.IList`1"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsDictionary">
            <summary>
            	Get underlying value as <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>Underlying <see cref="T:MsgPack.MessagePackObjectDictionary"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.FromObject(System.Object)">
            <summary>
            	Wraps specified object as <see cref="T:MsgPack.MessagePackObject"/> recursively.
            </summary>
            <param name="boxedValue">Object to be wrapped.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> wrapps <paramref name="boxedValue"/>.</returns>
            <exception cref="T:MsgPack.MessageTypeException">
            	<paramref name="boxedValue"/> is not primitive value type, list of <see cref="T:MsgPack.MessagePackObject"/>,
            	dictionary of <see cref="T:MsgPack.MessagePackObject"/>, <see cref="T:System.String"/>, <see cref="T:System.Byte"/>[], or null.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObject.ToObject">
            <summary>
            	Get boxed underlying value for this object.
            </summary>
            <returns>Boxed underlying value for this object.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Equality(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are equal each other or not.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Inequality(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Compare two instances are not equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are not equal each other or are equal.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(MsgPack.MessagePackObject[])~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:MsgPack.MessagePackObject"/>[] instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/>[] instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsNil">
            <summary>
            	Get whether this instance represents nil.
            </summary>
            <value>If this instance represents nil object, then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsRaw">
            <summary>
            	Get the value indicates whether this instance wraps raw binary (or string) or not.
            </summary>
            <value>This instance wraps raw binary (or string) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsList">
            <summary>
            	Get the value indicates whether this instance wraps list (array) or not.
            </summary>
            <value>This instance wraps list (array) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsArray">
            <summary>
            	Get the value indicates whether this instance wraps list (array) or not.
            </summary>
            <value>This instance wraps list (array) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsDictionary">
            <summary>
            	Get the value indicates whether this instance wraps dictionary (map) or not.
            </summary>
            <value>This instance wraps dictionary (map) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsMap">
            <summary>
            	Get the value indicates whether this instance wraps dictionary (map) or not.
            </summary>
            <value>This instance wraps dictionary (map) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.UnderlyingType">
            <summary>
            	Get underlying type of this instance.
            </summary>
            <returns>Underlying <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary">
            <summary>
            	Implements <see cref="T:System.Collections.Generic.IDictionary`2"/> for <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <remarks>
            	This dictionary handles <see cref="T:MsgPack.MessagePackObject"/> type semantics for the key.
            	Additionally, this dictionary implements 'freezing' feature. 
            	For details, see <see cref="P:MsgPack.MessagePackObjectDictionary.IsFrozen"/>, <see cref="M:MsgPack.MessagePackObjectDictionary.Freeze"/>, and <see cref="M:MsgPack.MessagePackObjectDictionary.AsFrozen"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.#ctor">
            <summary>
            Initializes an empty new instance of the <see cref="T:MsgPack.MessagePackObjectDictionary"/> class with default capacity.
            </summary>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.#ctor(System.Int32)">
            <summary>
            Initializes an empty new instance of the <see cref="T:MsgPack.MessagePackObjectDictionary"/> class with specified initial capacity.
            </summary>
            <param name="initialCapacity">The initial capacity.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="initialCapacity"/> is negative.
            </exception>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.#ctor(System.Collections.Generic.IDictionary{MsgPack.MessagePackObject,MsgPack.MessagePackObject})">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObjectDictionary"/> class.
            </summary>
            <param name="dictionary">The dictionary to be copied from.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="dictionary"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	Failed to copy from <paramref name="dictionary"/>.
            </exception>
            <remarks>
            	This constructor takes <em>O(N)</em> time, <em>N</em> is <see cref="P:ICollection{T}.Count"/> of <paramref name="dictionary"/>.
            	Initial capacity will be <see cref="P:ICollection{T}.Count"/> of <paramref name="dictionary"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ContainsKey(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <returns>
            	<c>true</c> if the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the key; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	This method approaches an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ContainsValue(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the specified value.
            </summary>
            <param name="value">The value to locate in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.</param>
            <returns>
            	<c>true</c> if the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the value; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	This method approaches an O(<em>N</em>) operation where <em>N</em> is <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.TryGetValue(MsgPack.MessagePackObject,MsgPack.MessagePackObject@)">
            <summary>
            	Gets the value associated with the specified key.
            </summary>
            <param name="key">
            	The key whose value to get.
            </param>
            <param name="value">
            	When this method returns, the value associated with the specified key, if the key is found; 
            	otherwise, the default value for the type of the <paramref name="value"/> parameter. 
            	This parameter is passed uninitialized.
            </param>
            <returns>
            	<c>true</c> if this dictionary contains an element with the specified key; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <remarks>
            	<para>
            		Note that tiny integers are considered equal regardless of its CLI <see cref="T:System.Type"/>,
            		and UTF-8 encoded bytes are considered equals to <see cref="T:System.String"/>.
            	</para>
            	<para>
            		This method approaches an O(1) operation.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Add(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">
            	The key of the element to add.
            </param>
            <param name="value">
            	The value of the element to add. The value can be <c>null</c> for reference types.
            </param>
            <returns>
            	An element with the same key already does not exist in the dictionary and sucess to add then newly added node;
            	otherwise <c>null</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            	<paramref name="key"/> already exists in this dictionary.
            	Note that tiny integers are considered equal regardless of its CLI <see cref="T:System.Type"/>,
            	and UTF-8 encoded bytes are considered equals to <see cref="T:System.String"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <remarks>
            	If <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/> is less than the capacity, this method approaches an O(1) operation.
            	If the capacity must be increased to accommodate the new element, 
            	this method becomes an O(<em>N</em>) operation, where <em>N</em> is <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/>. 
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Remove(MsgPack.MessagePackObject)">
            <summary>
            Removes the element with the specified key from the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            	<c>true</c> if the element is successfully removed; otherwise, <c>false</c>. 
            	This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <remarks>
            	This method approaches an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Clear">
            <summary>
            	Removes all items from the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <remarks>
            	This method approaches an O(<em>N</em>) operation, where <em>N</em> is <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.GetEnumerator">
            <summary>
            	Returns an enumerator that iterates through the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	Returns an enumerator that iterates through the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </returns>
            <remarks>
            	This method is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Freeze">
            <summary>
            	Freezes this instance.
            </summary>
            <returns>
            	This instance itself.
            	This value will not be <c>null</c> and its <see cref="P:MsgPack.MessagePackObjectDictionary.IsFrozen"/> is <c>true</c>.
            </returns>
            <remarks>
            	This method freezes this instance itself.
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.AsFrozen">
            <summary>
            	Gets a copy of this instance as frozen instance.
            </summary>
            <returns>
            	New <see cref="T:MsgPack.MessagePackObjectDictionary"/> instance which contains same items as this instance.
            	This value will not be <c>null</c> and its <see cref="P:MsgPack.MessagePackObjectDictionary.IsFrozen"/> is <c>true</c>.
            </returns>
            <remarks>
            	This method does not freeze this instance itself.
            	This operation is an O(<em>N</em>) operation where <em>O(N)</em> <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/> of items.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.IsFrozen">
            <summary>
            	Gets a value indicating whether this instance is frozen.
            </summary>
            <value>
            	<c>true</c> if this instance is frozen; otherwise, <c>false</c>.
            </value>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Count">
            <summary>
            	Gets the number of elements contained in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	The number of elements contained in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </returns>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Item(MsgPack.MessagePackObject)">
            <summary>
            	Gets or sets the element with the specified key.
            </summary>
            <value>
            	The element with the specified key.
            </value>
            <param name="key">Key for geting or seting value.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            	The property is retrieved and <paramref name="key"/> is not found.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            	The property is set and this instance is frozen.
            </exception>
            <remarks>
            	<para>
            		Note that tiny integers are considered equal regardless of its CLI <see cref="T:System.Type"/>,
            		and UTF-8 encoded bytes are considered equals to <see cref="T:System.String"/>.
            	</para>
            	<para>
            		This method approaches an O(1) operation.
            	</para>
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Keys">
            <summary>
            	Gets an <see cref="T:MsgPack.MessagePackObjectDictionary.KeyCollection"/> containing the keys of the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	An <see cref="T:MsgPack.MessagePackObjectDictionary.KeyCollection"/> containing the keys of the object.
            	This value will not be <c>null</c>.
            </returns>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Values">
            <summary>
            	Gets an <see cref="T:MsgPack.MessagePackObjectDictionary.ValueCollection"/> containing the values of the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	An <see cref="T:MsgPack.MessagePackObjectDictionary.ValueCollection"/> containing the values of the object.
            	This value will not be <c>null</c>.
            </returns>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.Enumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary"/> in order.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Enumerator.Dispose">
            <summary>
            	Releases all resources used by the this instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Enumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the underlying collection at the current position of the enumerator.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary"/> in order.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Entry">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <returns>
            	The element in the dictionary at the current position of the enumerator, as a <see cref="T:System.Collections.DictionaryEntry"/>
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Key">
            <summary>
            	Gets the key of the element at the current position of the enumerator.
            </summary>
            <returns>
            	The key of the element in the dictionary at the current position of the enumerator.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Value">
            <summary>
            	Gets the value of the element at the current position of the enumerator.
            </summary>
            <returns>
            	The value of the element in the dictionary at the current position of the enumerator.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.KeyCollection">
            <summary>
            	Represents the set of <see cref="T:MsgPack.MessagePackObjectDictionary"/> keys.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.CopyTo(MsgPack.MessagePackObject[])">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, starting at the beginning of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.CopyTo(MsgPack.MessagePackObject[],System.Int32)">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.CopyTo(System.Int32,MsgPack.MessagePackObject[],System.Int32,System.Int32)">
            <summary>
            	Copies a range of elements from this collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="index">
            	The zero-based index in the source dictionary at which copying begins. 
            </param>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
            <param name="count">
            	The number of elements to copy.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.System#Collections#Generic#ICollection{MsgPack#MessagePackObject}#Contains(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether this collection contains a specific value.
            </summary>
            <param name="item">
            	The object to locate in this collection.</param>
            <returns>
            	<c>true</c> if <paramref name="item"/> is found in this collection; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.GetEnumerator">
            <summary>
            	Returns an enumerator that iterates through this collction.
            </summary>
            <returns>
            	Returns an enumerator that iterates through this collction.
            </returns>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.KeyCollection.Count">
            <summary>
            	Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            	The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
              </returns>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.KeyCollection.Enumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary.KeyCollection"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.Enumerator.Dispose">
            <summary>
            	Releases all resources used by the this instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeyCollection.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.KeyCollection.Enumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the underlying collection at the current position of the enumerator.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.KeyCollection.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.ValueCollection">
            <summary>
            	Represents the collection of values in a <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.CopyTo(MsgPack.MessagePackObject[])">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, starting at the beginning of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.CopyTo(MsgPack.MessagePackObject[],System.Int32)">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.CopyTo(System.Int32,MsgPack.MessagePackObject[],System.Int32,System.Int32)">
            <summary>
            	Copies a range of elements from this collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="index">
            	The zero-based index in the source dictionary at which copying begins. 
            </param>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
            <param name="count">
            	The number of elements to copy.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.System#Collections#Generic#ICollection{MsgPack#MessagePackObject}#Contains(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether this collection contains a specific value.
            </summary>
            <param name="item">
            	The object to locate in this collection.</param>
            <returns>
            	<c>true</c> if <paramref name="item"/> is found in this collection; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.GetEnumerator">
            <summary>
            	Returns an enumerator that iterates through this collction.
            </summary>
            <returns>
            	Returns an enumerator that iterates through this collction.
            </returns>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.ValueCollection.Count">
            <summary>
            	Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            	The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
              </returns>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary.ValueCollection"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.Dispose">
            <summary>
            	Releases all resources used by the this instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the underlying collection at the current position of the enumerator.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectEqualityComparer">
            <summary>
            	Implements <see cref="T:System.Collections.Generic.EqualityComparer`1"/> of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectEqualityComparer.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObjectEqualityComparer"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectEqualityComparer.Equals(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Determines whether two objects of type <see cref="T:MsgPack.MessagePackObject"/> are equal.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
            	<c>true</c> if the specified objects are equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObjectEqualityComparer.GetHashCode(MsgPack.MessagePackObject)">
            <summary>
            	Returns a hash code for the specified <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <param name="obj">The <see cref="T:MsgPack.MessagePackObject"/>.</param>
            <returns>
            	A hash code for <paramref name="obj"/>, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:MsgPack.MessagePackString">
            <summary>
            	Encapselates <see cref="T:System.String"/> and its serialized UTF-8 bytes.
            </summary>
        </member>
        <member name="T:MsgPack.MessageTypeException">
            <summary>
            	Represents unpacking error when message type is unknown or unavailable.
            </summary>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="T:MsgPack.Packer">
            <summary>
            	Implements serialization feature of MsgPack.
            </summary>
        </member>
        <member name="M:MsgPack.Packer.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Packer"/> class with <see cref="P:MsgPack.Packer.DefaultCompatibilityOptions"/>.
            </summary>
        </member>
        <member name="M:MsgPack.Packer.#ctor(MsgPack.PackerCompatibilityOptions)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Packer"/> class with specified <see cref="T:MsgPack.PackerCompatibilityOptions"/>.
            </summary>
            <param name="compatibilityOptions">A <see cref="T:MsgPack.PackerCompatibilityOptions"/> which specifies compatibility options.</param>
        </member>
        <member name="M:MsgPack.Packer.Create(System.IO.Stream)">
            <summary>
            	Create standard Safe <see cref="T:MsgPack.Packer"/> instancde wrapping specified <see cref="T:System.IO.Stream"/> with <see cref="P:MsgPack.Packer.DefaultCompatibilityOptions"/>.
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> object. This stream will be closed when <see cref="M:MsgPack.Packer.Dispose(System.Boolean)"/> is called.</param>
            <returns>Safe <see cref="T:MsgPack.Packer"/>. This will not be null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <remarks>
            	 You can specify any derived <see cref="T:System.IO.Stream"/> class like FileStream, <see cref="T:System.IO.MemoryStream"/>,
            	 NetworkStream, UnmanagedMemoryStream, or so.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.Create(System.IO.Stream,MsgPack.PackerCompatibilityOptions)">
            <summary>
            	Create standard Safe <see cref="T:MsgPack.Packer"/> instancde wrapping specified <see cref="T:System.IO.Stream"/> with specified <see cref="T:MsgPack.PackerCompatibilityOptions"/>.
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> object. This stream will be closed when <see cref="M:MsgPack.Packer.Dispose(System.Boolean)"/> is called.</param>
            <param name="compatibilityOptions">A <see cref="T:MsgPack.PackerCompatibilityOptions"/> which specifies compatibility options.</param>
            <returns>Safe <see cref="T:MsgPack.Packer"/>. This will not be null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <remarks>
            	 You can specify any derived <see cref="T:System.IO.Stream"/> class like FileStream, <see cref="T:System.IO.MemoryStream"/>,
            	 NetworkStream, UnmanagedMemoryStream, or so.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.Create(System.IO.Stream,System.Boolean)">
            <summary>
            	Create standard Safe <see cref="T:MsgPack.Packer"/> instancde wrapping specified <see cref="T:System.IO.Stream"/> with <see cref="P:MsgPack.Packer.DefaultCompatibilityOptions"/>.
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> object.</param>
            <param name="ownsStream">
            	<c>true</c> to close <paramref name="stream"/> when this instance is disposed;
            	<c>false</c>, otherwise.
            </param>
            <returns>Safe <see cref="T:MsgPack.Packer"/>. This will not be null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <remarks>
            	 You can specify any derived <see cref="T:System.IO.Stream"/> class like FileStream, <see cref="T:System.IO.MemoryStream"/>,
            	 NetworkStream, UnmanagedMemoryStream, or so.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.Create(System.IO.Stream,MsgPack.PackerCompatibilityOptions,System.Boolean)">
            <summary>
            	Create standard Safe <see cref="T:MsgPack.Packer"/> instancde wrapping specified <see cref="T:System.IO.Stream"/> with specified <see cref="T:MsgPack.PackerCompatibilityOptions"/>.
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> object.</param>
            <param name="compatibilityOptions">A <see cref="T:MsgPack.PackerCompatibilityOptions"/> which specifies compatibility options.</param>
            <param name="ownsStream">
            	<c>true</c> to close <paramref name="stream"/> when this instance is disposed;
            	<c>false</c>, otherwise.
            </param>
            <returns>Safe <see cref="T:MsgPack.Packer"/>. This will not be null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <remarks>
            	 You can specify any derived <see cref="T:System.IO.Stream"/> class like FileStream, <see cref="T:System.IO.MemoryStream"/>,
            	 NetworkStream, UnmanagedMemoryStream, or so.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.Dispose">
            <summary>
            	Clean up internal resources.
            </summary>
        </member>
        <member name="M:MsgPack.Packer.Dispose(System.Boolean)">
            <summary>
            	When overridden by derived class, release all unmanaged resources, optionally release managed resources.
            </summary>
            <param name="disposing">If true, release managed resources too.</param>
        </member>
        <member name="M:MsgPack.Packer.SeekTo(System.Int64)">
            <summary>
            	When overridden by derived class, change current position to specified offset.
            </summary>
            <param name="offset">Offset. You shoud not specify the value which causes underflow or overflow.</param>
            <exception cref="T:System.NotSupportedException">
            	A class of this instance does not support seek.
            </exception>
        </member>
        <member name="M:MsgPack.Packer.WriteByte(System.Byte)">
            <summary>
            	When overridden by derived class, writes specified byte to stream using implementation specific manner.
            </summary>
            <param name="value">A byte to be written.</param>
        </member>
        <member name="M:MsgPack.Packer.WriteBytes(System.Collections.Generic.ICollection{System.Byte})">
            <summary>
            	Writes specified bytes to stream using implementation specific most efficient manner.
            </summary>
            <param name="value">Collection of bytes to be written.</param>
        </member>
        <member name="M:MsgPack.Packer.WriteBytes(System.Byte[],System.Boolean)">
            <summary>
            	Writes specified bytes to stream using implementation specific most efficient manner.
            </summary>
            <param name="value">Bytes to be written.</param>
            <param name="isImmutable">If the <paramref name="value"/> can be treat as immutable (that is, can be used safely without copying) then <c>true</c>.</param>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.SByte)">
            <summary>
            	Packs <see cref="T:System.SByte"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.SByte"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt8(System.Int64)">
            <summary>
            	Try packs <see cref="T:System.SByte"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.SByte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Byte)">
            <summary>
            	Packs <see cref="T:System.Byte"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt8(System.UInt64)">
            <summary>
            	Try packs <see cref="T:System.Byte"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Byte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Int16)">
            <summary>
            	Packs <see cref="T:System.Int16"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Int16"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt16(System.Int64)">
            <summary>
            	Try packs <see cref="T:System.Int16"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Int16"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.UInt16)">
            <summary>
            	Packs <see cref="T:System.UInt16"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.UInt16"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt16(System.UInt64)">
            <summary>
            	Try packs <see cref="T:System.UInt16"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.UInt16"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Int32)">
            <summary>
            	Packs <see cref="T:System.Int32"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Int32"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt32(System.Int64)">
            <summary>
            	Try packs <see cref="T:System.Int32"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Int32"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.UInt32)">
            <summary>
            	Packs <see cref="T:System.UInt32"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.UInt32"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt32(System.UInt64)">
            <summary>
            	Try packs <see cref="T:System.UInt32"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.UInt32"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Int64)">
            <summary>
            	Packs <see cref="T:System.Int64"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Int64"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt64(System.Int64)">
            <summary>
            	Try packs <see cref="T:System.Int64"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Int64"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.UInt64)">
            <summary>
            	Packs <see cref="T:System.UInt64"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.UInt64"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt64(System.UInt64)">
            <summary>
            	Try packs <see cref="T:System.UInt64"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.UInt64"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Single)">
            <summary>
            	Packs <see cref="T:System.Single"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Single"/> value.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Double)">
            <summary>
            	Packs <see cref="T:System.Double"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Double"/> value.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Boolean)">
            <summary>
            	Packs <see cref="T:System.Boolean"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Boolean"/> value.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackArrayHeader(System.Int32)">
            <summary>
            	Bookkeep array length to be packed on current stream.
            </summary>
            <param name="count">Array length.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackArrayHeaderCore(System.Int32)">
            <summary>
            	Bookkeep array length to be packed on current stream.
            </summary>
            <param name="count">Array length.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackMapHeader(System.Int32)">
            <summary>
            	Bookkeep dictionary items count to be packed on current stream.
            </summary>
            <param name="count">Dictionary items count.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackMapHeaderCore(System.Int32)">
            <summary>
            	Bookkeep dictionary items count to be packed on current stream.
            </summary>
            <param name="count">Dictionary items count.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackRawHeader(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method acts as alias of <see cref="M:MsgPack.Packer.PackStringHeader(System.Int32)"/> for compatibility.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackStringHeader(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream as the bytes may represent well formed encoded string.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackBinaryHeader(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream as the bytes do not represent well formed encoded string.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackRawHeaderCore(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
            <remarks>
            	This method acts as alias of <see cref="M:MsgPack.Packer.PackStringHeaderCore(System.Int32)"/> for compatibility.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackStringHeaderCore(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream as the bytes may represent well formed encoded string.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackBinaryHeaderCore(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream as the bytes do not represent well formed encoded string.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackRaw(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            	Packs specified byte stream to current stream.
            </summary>
            <param name="value">Source bytes its size is not known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method use str types (previously known as raw types) for compability.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackRaw(System.Collections.Generic.IList{System.Byte})">
            <summary>
            	Packs specified byte stream to current stream.
            </summary>
            <param name="value">Source bytes its size is known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method use str types (previously known as raw types) for compability.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackRaw(System.Byte[])">
            <summary>
            	Packs specified byte array to current stream.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method use str types (previously known as raw types) for compability.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackRawBody(System.Byte[])">
            <summary>
            	Packs specified byte array to current stream without any header.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	If you forget to write header first, then resulting stream will be corrupsed.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackRawBody(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            	Packs specified byte sequence to current stream without any header.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	If you forget to write header first, then resulting stream will be corrupsed.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            	Packs specified char stream to current stream with UTF-8 <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source chars its size is not known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.String)">
            <summary>
            	Packs specified string to current stream with UTF-8 <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source string.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.Collections.Generic.IEnumerable{System.Char},System.Text.Encoding)">
            <summary>
            	Packs specified char stream to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source chars its size is not known.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.String,System.Text.Encoding)">
            <summary>
            	Packs specified string to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source string.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackStringCore(System.Collections.Generic.IEnumerable{System.Char},System.Text.Encoding)">
            <summary>
            	Packs specified char stream to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source chars its size is not known.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
        </member>
        <member name="M:MsgPack.Packer.PackStringCore(System.String,System.Text.Encoding)">
            <summary>
            	Packs specified string to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source string.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
        </member>
        <member name="M:MsgPack.Packer.PackBinary(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            	Packs specified byte stream to current stream.
            </summary>
            <param name="value">Source bytes its size is not known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method use bin types unless <see cref="P:MsgPack.Packer.CompatibilityOptions"/> contains <see cref="F:MsgPack.PackerCompatibilityOptions.PackBinaryAsRaw"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackBinary(System.Collections.Generic.IList{System.Byte})">
            <summary>
            	Packs specified byte stream to current stream.
            </summary>
            <param name="value">Source bytes its size is known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method use bin types unless <see cref="P:MsgPack.Packer.CompatibilityOptions"/> contains <see cref="F:MsgPack.PackerCompatibilityOptions.PackBinaryAsRaw"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackBinary(System.Byte[])">
            <summary>
            	Packs specified byte array to current stream.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	This method use bin types unless <see cref="P:MsgPack.Packer.CompatibilityOptions"/> contains <see cref="F:MsgPack.PackerCompatibilityOptions.PackBinaryAsRaw"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackArrayHeader``1(System.Collections.Generic.IList{``0})">
            <summary>
            	Bookkeep collection count to be packed on current stream.
            </summary>
            <param name="array">Collection count to be written.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackMapHeader``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            	Bookkeep dictionary count to be packed on current stream.
            </summary>
            <param name="map">Dictionary count to be written.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackTinySignedInteger(System.Int64)">
            <summary>
            	Try packs <see cref="T:System.SByte"/> value to current stream as tiny fix num.
            </summary>
            <param name="value">Maybe tiny <see cref="T:System.SByte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.TryPackTinyUnsignedInteger(System.UInt64)">
            <summary>
            	Try packs <see cref="T:System.Byte"/> value to current stream as tiny fix num.
            </summary>
            <param name="value">Maybe tiny <see cref="T:System.Byte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.PackNull">
            <summary>
            	Packs a null value to current stream.
            </summary>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackExtendedTypeValue(System.Byte,System.Byte[])">
            <summary>
            Packs an extended type value.
            </summary>
            <param name="typeCode">A type code of the extended type value.</param>
            <param name="body">A binary value portion of the extended type value.</param>
            <returns>This instance. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:MsgPack.Packer.CompatibilityOptions"/> property contains <see cref="F:MsgPack.PackerCompatibilityOptions.ProhibitExtendedTypeObjects"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackExtendedTypeValue(MsgPack.MessagePackExtendedTypeObject)">
            <summary>
            	Packs an extended type value.
            </summary>
            <param name="mpeto">A <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> to be packed.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ArgumentException"><see cref="P:MsgPack.MessagePackExtendedTypeObject.IsValid"/> of <paramref name="mpeto"/> is <c>false</c>.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:MsgPack.Packer.CompatibilityOptions"/> property contains <see cref="F:MsgPack.PackerCompatibilityOptions.ProhibitExtendedTypeObjects"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.SByte})">
            <summary>
            	Pack nullable <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Byte})">
            <summary>
            	Pack nullable <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Int16})">
            <summary>
            	Pack nullable <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.UInt16})">
            <summary>
            	Pack nullable <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Int32})">
            <summary>
            	Pack nullable <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.UInt32})">
            <summary>
            	Pack nullable <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Int64})">
            <summary>
            	Pack nullable <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.UInt64})">
            <summary>
            	Pack nullable <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Single})">
            <summary>
            	Pack nullable <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Double})">
            <summary>
            	Pack nullable <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Boolean})">
            <summary>
            	Pack nullable <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="P:MsgPack.Packer.DefaultCompatibilityOptions">
            <summary>
            	Gets or sets the default <see cref="T:MsgPack.PackerCompatibilityOptions"/> for all instances.
            </summary>
            <value>
            	The default <see cref="T:MsgPack.PackerCompatibilityOptions"/>.
            	The default value is <see cref="F:MsgPack.PackerCompatibilityOptions.Classic"/>.
            </value>
            <remarks>
            	<para>
            		Note that modification of this value will affect all new instances from the point.
            		Existent instances are not afectted by the modification.
            	</para>
            	<para>
            		This property is intended to be set in application initialization code.
            	</para>
            	<para>
            		Note that the default value is <see cref="F:MsgPack.PackerCompatibilityOptions.Classic"/>, not <see cref="F:MsgPack.PackerCompatibilityOptions.None"/>.
            	</para>
            </remarks>
        </member>
        <member name="P:MsgPack.Packer.CanSeek">
            <summary>
            	Get whether this class supports seek operation and quering <see cref="P:MsgPack.Packer.Position"/> property.
            </summary>
            <value>If this class supports seek operation and quering <see cref="P:MsgPack.Packer.Position"/> property then true.</value>
        </member>
        <member name="P:MsgPack.Packer.Position">
            <summary>
            	Get current position of underlying stream.
            </summary>
            <value>Opaque position value of underlying stream.</value>
            <exception cref="T:System.NotSupportedException">
            	A class of this instance does not support seek.
            </exception>
        </member>
        <member name="P:MsgPack.Packer.CompatibilityOptions">
            <summary>
            	Gets a compatibility options for this instance.
            </summary>
            <value>
            	The compatibility options.
            </value>
        </member>
        <member name="T:MsgPack.PackerCompatibilityOptions">
            <summary>
            	Defines compatibility options for <see cref="T:MsgPack.Packer"/>.
            </summary>
        </member>
        <member name="F:MsgPack.PackerCompatibilityOptions.None">
            <summary>
            	No compatibility options. <see cref="T:MsgPack.Packer"/>s use newest behavior.
            </summary>
        </member>
        <member name="F:MsgPack.PackerCompatibilityOptions.PackBinaryAsRaw">
            <summary>
            	Packs byte array as raw(str) value, and also prohibits usage of str8 type for legacy unpacker implementations.
            </summary>
        </member>
        <member name="F:MsgPack.PackerCompatibilityOptions.ProhibitExtendedTypeObjects">
            <summary>
            	Prohibits usage of any ext types for legacy unpacker implementations.
            </summary>
        </member>
        <member name="F:MsgPack.PackerCompatibilityOptions.Classic">
            <summary>
            	<see cref="T:MsgPack.Packer"/>s should be use classic behavior. That is, do not use str8 and any ext types, and byte arrays must be packed as raw.
            </summary>
        </member>
        <member name="T:MsgPack.PackingOptions">
            <summary>
            	Represents options of packing.
            </summary>
        </member>
        <member name="M:MsgPack.PackingOptions.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.PackingOptions"/> class.
            </summary>
        </member>
        <member name="P:MsgPack.PackingOptions.StringEncoding">
            <summary>
            	Get encoding for string.
            </summary>
            <value>
            	<see cref="T:System.Text.Encoding"/> for string. Default is UTF-8 encoding without BOM.
            </value>
        </member>
        <member name="T:MsgPack.StreamPacker">
            <summary>
            	Basic <see cref="T:MsgPack.Packer"/> implementation using managed <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="T:MsgPack.SubtreeUnpacker">
            <summary>
            	Defines subtree unpacking unpacker.
            </summary>
        </member>
        <member name="T:MsgPack.UnassignedMessageTypeException">
            <summary>
            	Represents unpacking error when message type is not valid because 0xC1 will never be assigned.
            </summary>
        </member>
        <member name="M:MsgPack.UnassignedMessageTypeException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnassignedMessageTypeException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.UnassignedMessageTypeException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnassignedMessageTypeException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.UnassignedMessageTypeException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnassignedMessageTypeException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="T:MsgPack.UnpackException">
            <summary>
            	Represents generic unpacking error.
            </summary>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="T:MsgPack.Unpacking">
            <summary>
            	Defines direct conversion value from/to Message Pack binary stream without intermediate <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <remarks>
            	This class provides convinient way to unpack objects from wellknown seekable stream.
            	This class does not support stream feeding.
            </remarks>
            <seealso cref="T:MsgPack.Unpacker"/>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByte(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Byte"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/> which contains unpacked <see cref="T:System.Byte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackByte(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByte(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Byte"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/> which contains unpacked <see cref="T:System.Byte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByte(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Byte"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Byte"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSByte(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.SByte"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.SByte"/> which contains unpacked <see cref="T:System.SByte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.SByte"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackSByte(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSByte(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.SByte"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.SByte"/> which contains unpacked <see cref="T:System.SByte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.SByte"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSByte(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.SByte"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.SByte"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.SByte"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt16(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Int16"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int16"/> which contains unpacked <see cref="T:System.Int16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int16"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackInt16(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt16(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Int16"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int16"/> which contains unpacked <see cref="T:System.Int16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int16"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt16(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Int16"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Int16"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int16"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt16(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.UInt16"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt16"/> which contains unpacked <see cref="T:System.UInt16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt16"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackUInt16(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt16(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.UInt16"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt16"/> which contains unpacked <see cref="T:System.UInt16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt16"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt16(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.UInt16"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.UInt16"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt16"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt32(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Int32"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int32"/> which contains unpacked <see cref="T:System.Int32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int32"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackInt32(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt32(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Int32"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int32"/> which contains unpacked <see cref="T:System.Int32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int32"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt32(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Int32"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Int32"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int32"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt32(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.UInt32"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt32"/> which contains unpacked <see cref="T:System.UInt32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt32"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackUInt32(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt32(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.UInt32"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt32"/> which contains unpacked <see cref="T:System.UInt32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt32"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt32(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.UInt32"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.UInt32"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt32"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt64(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Int64"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int64"/> which contains unpacked <see cref="T:System.Int64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackInt64(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt64(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Int64"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int64"/> which contains unpacked <see cref="T:System.Int64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt64(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Int64"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Int64"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt64(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.UInt64"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt64"/> which contains unpacked <see cref="T:System.UInt64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackUInt64(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt64(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.UInt64"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt64"/> which contains unpacked <see cref="T:System.UInt64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt64(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.UInt64"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.UInt64"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSingle(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Single"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Single"/> which contains unpacked <see cref="T:System.Single"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Single"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackSingle(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSingle(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Single"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Single"/> which contains unpacked <see cref="T:System.Single"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Single"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSingle(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Single"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Single"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Single"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDouble(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Double"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Double"/> which contains unpacked <see cref="T:System.Double"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Double"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackDouble(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDouble(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Double"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Double"/> which contains unpacked <see cref="T:System.Double"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Double"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDouble(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Double"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Double"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Double"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArray(System.Byte[])">
            <summary>
            	Unpacks the array from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> which contains unpacked the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackArray(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArray(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the array from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> which contains unpacked the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArray(System.IO.Stream)">
            <summary>
            	Unpacks the array value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the array value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Collections.Generic.IList`1"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArrayLength(System.Byte[])">
            <summary>
            	Unpacks length of the array from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked length of the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackArrayLength(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArrayLength(System.Byte[],System.Int32)">
            <summary>
            	Unpacks length of the array from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked length of the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArrayLength(System.IO.Stream)">
            <summary>
            	Unpacks length of the array value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked length of the array value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionary(System.Byte[])">
            <summary>
            	Unpacks the dictionary from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObjectDictionary"/> which contains unpacked the dictionary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackDictionary(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionary(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the dictionary from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObjectDictionary"/> which contains unpacked the dictionary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionary(System.IO.Stream)">
            <summary>
            	Unpacks the dictionary value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the dictionary value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionaryCount(System.Byte[])">
            <summary>
            	Unpacks count of the dictionary entries from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked count of the dictionary entries and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackDictionaryCount(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionaryCount(System.Byte[],System.Int32)">
            <summary>
            	Unpacks count of the dictionary entries from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked count of the dictionary entries and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionaryCount(System.IO.Stream)">
            <summary>
            	Unpacks count of the dictionary entries value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked count of the dictionary entries value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBinary(System.Byte[])">
            <summary>
            	Unpacks the raw binary from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/>[] which contains unpacked the raw binary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>[].
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackBinary(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBinary(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the raw binary from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/>[] which contains unpacked the raw binary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>[].
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBinary(System.IO.Stream)">
            <summary>
            	Unpacks the raw binary value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the raw binary value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>[].
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBoolean(System.Byte[])">
            <summary>
            	Unpacks the boolean from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Boolean"/> which contains unpacked the boolean and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Boolean"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackBoolean(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBoolean(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the boolean from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Boolean"/> which contains unpacked the boolean and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Boolean"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBoolean(System.IO.Stream)">
            <summary>
            	Unpacks the boolean value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the boolean value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Boolean"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackNull(System.Byte[])">
            <summary>
            	Unpacks the nil from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Object"/> which contains unpacked the nil and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Object"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackNull(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackNull(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the nil from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Object"/> which contains unpacked the nil and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Object"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackNull(System.IO.Stream)">
            <summary>
            	Unpacks the nil value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the nil value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Object"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackObject(System.Byte[])">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObject"/> which contains unpacked the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObject"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObject"/> which contains unpacked the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObject"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObject"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackExtendedTypeObject(System.Byte[])">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which represents the extended type value. from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which contains unpacked the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which represents the extended type value. and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackExtendedTypeObject(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackExtendedTypeObject(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which represents the extended type value. from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which contains unpacked the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which represents the extended type value. and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackExtendedTypeObject(System.IO.Stream)">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which represents the extended type value. value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the <see cref="T:MsgPack.MessagePackExtendedTypeObject"/> which represents the extended type value. value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackExtendedTypeObject"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByteStream(System.IO.Stream)">
            <summary>
            	Unpacks raw value from the specified <see cref="T:System.IO.Stream"/> as <see cref="T:MsgPack.UnpackingStream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingStream"/> which represents raw value stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		<see cref="T:MsgPack.UnpackingStream"/> does not own <paramref name="source"/>, so <paramref name="source"/> still should be closed.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackCharStream(System.IO.Stream)">
            <summary>
            	Unpacks raw value from the specified <see cref="T:System.IO.Stream"/> as <see cref="T:MsgPack.UnpackingStreamReader"/> with UTF-8 encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingStreamReader"/> which represents raw value stream as UTF-8 string.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		if <paramref name="source"/> contains invalid sequence as UTF-8 encoding string,
            		the <see cref="T:System.Text.DecoderFallbackException"/> may occurs on read char.
            	</para>
            	<para>
            		<see cref="T:MsgPack.UnpackingStreamReader"/> does not own <paramref name="source"/>, so <paramref name="source"/> still should be closed.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackCharStream(System.IO.Stream,System.Text.Encoding)">
            <summary>
            	Unpacks raw value from the specified <see cref="T:System.IO.Stream"/> as <see cref="T:MsgPack.UnpackingStreamReader"/> with specified encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingStreamReader"/> which represents raw value stream as UTF-8 string.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or, <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		if <paramref name="source"/> contains invalid sequence as specified encoding string,
            		the <see cref="T:System.Text.DecoderFallbackException"/> may occurs on read char.
            	</para>
            	<para>
            		<see cref="T:MsgPack.UnpackingStreamReader"/> does not own <paramref name="source"/>, so <paramref name="source"/> still should be closed.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>		
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the head of specified byte array with UTF-8 encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as UTF-8 encoded byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Text.Encoding)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the head of specified byte array with specified encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or, <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as UTF-8 encoded byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from specified offsetted byte array with UTF-8 encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not greater than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as specified encoding byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from specified offsetted byte array with specified encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or, <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not greater than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as specified encoding byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the specified <see cref="T:System.IO.Stream"/> with UTF-8 encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.String"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as UTF-8 encoded byte stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.IO.Stream,System.Text.Encoding)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the specified <see cref="T:System.IO.Stream"/> with specified encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.String"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as specified encoding byte stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="T:MsgPack.UnpackingStream">
            <summary>
            	Represents raw binary as read only <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            	<para>
            		This object behaves as wrapper of the underlying <see cref="T:System.IO.Stream"/> which contains message pack encoded byte array.
            		But, this object does not own the stream, so that stream is not closed when this stream is closed.
            	</para>
            	<para>
            		The value of <see cref="M:Stream.CanSeek"/>, timeout, and async API depends on the underlying stream.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.UnpackingStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            	Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">
            	An array of bytes. When this method returns, 
            	the buffer contains the specified byte array with the values between <paramref name="offset"/> and ( <paramref name="offset"/> + <paramref name="count"/> - 1) 
            	replaced by the bytes read from the current source. 
            </param>
            <param name="offset">
            	The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.
            </param>
            <param name="count">
            	The maximum number of bytes to be read from the current stream.
            </param>
            <returns>
            	The total number of bytes read into the buffer. 
            	This can be less than the number of bytes requested if that many bytes are not currently available,
            	or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">
            	The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="buffer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> or <paramref name="count"/> is negative. 
            </exception>
            <exception cref="T:System.IO.IOException">
            	An I/O error occurs.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed.
            </exception>
            <remarks>
            	<note>
            		Arguments might be passed to the underlying <see cref="T:System.IO.Stream"/> without any validation.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.UnpackingStream.Flush">
            <summary>
            	Overrides <see cref="M:Stream.Flush()"/> so that no action is performed. 
            </summary>
        </member>
        <member name="M:MsgPack.UnpackingStream.SetLength(System.Int64)">
            <summary>
            	Throws <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">Never used.</param>
            <exception cref="T:System.NotSupportedException">
            	Always thrown.
            </exception>
        </member>
        <member name="M:MsgPack.UnpackingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            	Throws <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="buffer">Never used.</param>
            <param name="offset">Never used.</param>
            <param name="count">Never used.</param>
            <exception cref="T:System.NotSupportedException">
            	Always thrown.
            </exception>
        </member>
        <member name="P:MsgPack.UnpackingStream.CanRead">
            <summary>
            	Gets a value indicating whether the current stream supports reading.
            </summary>
            <value>Always <c>true</c>.</value>
        </member>
        <member name="P:MsgPack.UnpackingStream.CanWrite">
            <summary>
            	Gets a value indicating whether the current stream supports writing.
            </summary>
            <value>Always <c>false</c>.</value>
        </member>
        <member name="P:MsgPack.UnpackingStream.Length">
            <summary>
            	Gets the length in bytes of the stream.
            </summary>
            <value>
            	A long value representing the length of the raw binary length.
            	This value must be between 0 and <see cref="F:System.Int32.MaxValue"/>.
            </value>
            <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed.
            </exception>
            <remarks>
            	This property never throws <see cref="T:System.NotSupportedException"/> even if <see cref="M:Stream.CanSeek"/> is <c>false</c>.
            </remarks>
        </member>
        <member name="P:MsgPack.UnpackingStream.CanTimeout">
            <summary>
            	Gets a value that determines whether the current stream can time out.
            </summary>
            <value>
            	A value that determines whether the current stream can time out.
            </value>
            <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="T:MsgPack.UnpackingStreamReader">
            <summary>
            	Implements <see cref="T:System.IO.TextReader"/> which reads raw binary <see cref="T:System.IO.Stream"/> with specific <see cref="T:System.Text.Encoding"/>.
            </summary>
        </member>
        <member name="P:MsgPack.UnpackingStreamReader.ByteLength">
            <summary>
            	Gets the length of the underlying raw binary length.
            </summary>
            <value>
            	The length of the underlying raw binary length.
            	This value will not be negative.
            </value>
        </member>
        <member name="T:MsgPack.UnpackingResult`1">
            <summary>
            	Represents result of direct conversion from the byte array.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.Equals(System.Object)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="obj"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	If <paramref name="obj"/> is <see cref="T:MsgPack.UnpackingResult`1"/> and its value is equal to this instance, then true.
            	Otherwise false.
            </returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.Equals(MsgPack.UnpackingResult{`0})">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="other"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	Whether value of <paramref name="other"/> is equal to this instance or not.
            </returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.GetHashCode">
            <summary>
            	Get hash code of this instance.
            </summary>
            <returns>Hash code of this instance.</returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.ToString">
            <summary>
            	Get string representation of this object.
            </summary>
            <returns>String representation of this object.</returns>
            <remarks>
            	<note>
            		DO NOT use this value programmically. 
            		The purpose of this method is informational, so format of this value subject to change.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.op_Equality(MsgPack.UnpackingResult{`0},MsgPack.UnpackingResult{`0})">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are equal each other or not.
            </returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.op_Inequality(MsgPack.UnpackingResult{`0},MsgPack.UnpackingResult{`0})">
            <summary>
            	Compare two instances are not equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are not equal each other or are equal.
            </returns>		
        </member>
        <member name="P:MsgPack.UnpackingResult`1.ReadCount">
            <summary>
            	Get read bytes count from input byte array.
            </summary>
            <value>
            	Read bytes count from input byte array.
            	If this value equals to old offset, then a value of <see cref="P:MsgPack.UnpackingResult`1.Value"/> property is not undifined.
            </value>
        </member>
        <member name="P:MsgPack.UnpackingResult`1.Value">
            <summary>
            	Get retrieved value from the byte array.
            </summary>
            <value>
            	Retrieved value from the byte array.
            	If <see cref="P:MsgPack.UnpackingResult`1.ReadCount"/> equals to old offset, then a value of this property is not undefined.
            </value>
        </member>
        <member name="T:MsgPack.Validation">
            <summary>
            	Common validtion utility.
            </summary>
        </member>
        <member name="M:MsgPack.Validation.IsPrintable(System.Globalization.UnicodeCategory)">
            <summary>
            	Determine specified category is printiable.
            </summary>
            <param name="category">Unicode cateory.</param>
            <returns>
            	If all charactors in specified category are printable then true.
            	Other wise false.
            </returns>
            <remarks>
            	This method is conservative, but application cannot print the charactor
            	because appropriate font is not installed the machine.
            </remarks>
        </member>
    </members>
</doc>
